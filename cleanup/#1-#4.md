# Implementation Plan: Priority Items 1-4

I'll provide concrete implementations for each critical item. Given context limits, I'll create artifacts for the complex changes and provide clear instructions for simpler ones.

## 1. Service Worker Bootloader (HIGHEST PRIORITY)## 2. Error Boundaries & Silent Failures## 3. Memory Management## 4. Persistence Layer - Single Source of Truth## Integration Instructions## Summary
# Integration Guide: Critical Fixes 1-4

## Overview
This guide provides step-by-step instructions to integrate the four critical fixes into the Singularity codebase. Each section includes the target file, changes needed, and validation steps.

---

## 1. Service Worker Bootloader (HIGHEST PRIORITY)

### Target File: `src/sw-entry.js`

### Changes Required:

1. **Add module-level promise** at the top of the file (after imports):
```javascript
let globalServicesPromise = null;
```

2. **Move listener attachments** to be BEFORE the main IIFE:
   - Cut the `chrome.runtime.onMessage.addListener` block
   - Cut the `chrome.runtime.onConnect.addListener` block
   - Paste them BEFORE the main IIFE `(async () => { ... })()`
   - This ensures listeners are attached synchronously

3. **Modify listeners** to use stall-and-load pattern:
   - Inside each listener, add: `const services = await initializeGlobalServices();`
   - Remove any direct references to `sessionManager` before this line
   - After awaiting services, assign: `sessionManager = services.sessionManager;`

4. **Split initialization** into eager and lazy:
   - Move DNR initialization to the main IIFE (eager path):
     ```javascript
     await NetRulesManager.init();
     await ArkoseController.init();
     ```
   - Create new function `initializeGlobalInfrastructure_NonDNR()` that excludes DNR
   - Call this in `initializeGlobalServices()` instead of full infrastructure init

5. **Update initializeGlobalServices()** to be memoized:
```javascript
async function initializeGlobalServices() {
  if (globalServicesPromise) return globalServicesPromise;
  
  globalServicesPromise = (async () => {
    // ... initialization code
    return { orchestrator, sessionManager, compiler, contextResolver, persistenceLayer, promptRefinerService };
  })();
  
  return globalServicesPromise;
}
```

### Validation:
- Open Chrome DevTools â†’ Application â†’ Service Workers
- Verify SW shows "activated and running" immediately
- Check console for: `[SW] âœ… Listeners attached (synchronous)`
- Test on a slow machine or throttle CPU to 4x slowdown

---

## 2. Error Boundaries & Silent Failures

### Target File: `src/core/workflow-engine.js`

### Changes Required:

1. **Add onError callback** to orchestrator calls in `executePromptStep()`:
```javascript
this.orchestrator.executeParallelFanout(prompt, providers, {
  // ... existing callbacks
  onError: (error) => {
    console.error('[WorkflowEngine] Orchestrator error:', error);
    
    // Send error to UI
    this.port.postMessage({
      type: "WORKFLOW_STEP_UPDATE",
      sessionId: context.sessionId,
      stepId: step.stepId,
      status: "partial_failure",
      error: error.message,
      partialResults: Object.fromEntries(results),
    });
    
    // Graceful degradation: accept partial results
    if (results.size > 0) {
      resolve({ results: Object.fromEntries(results), errors, partial: true });
    } else {
      reject(error);
    }
  },
  // ... rest of callbacks
});
```

2. **Wrap step execution** in try-catch blocks in `execute()` method:
   - Wrap each `for (const step of promptSteps)` loop body in try-catch
   - Wrap each `for (const step of synthesisSteps)` loop body in try-catch
   - Wrap each `for (const step of mappingSteps)` loop body in try-catch
   - On catch: log error, update UI, decide whether to continue or exit

3. **Add finally block** to `execute()`:
```javascript
} finally {
  // Always clean up delta cache
  clearDeltaCache(context.sessionId);
}
```

### Target File: `ui/components/AiTurnBlock.tsx`

### Changes Required:

1. **Wrap component** in ErrorBoundary (already exists, just ensure usage):
```typescript
// In parent component (ChatView.tsx):
<ErrorBoundary>
  <AiTurnBlock {...props} />
</ErrorBoundary>
```

### Validation:
- Simulate provider failure (disconnect network during request)
- Verify UI shows error message instead of infinite spinner
- Check console for graceful degradation logs
- Confirm partial results display when available

---

## 3. Memory Management

### Target File: `ui/utils/streamingBuffer.ts`

### Changes Required:

1. **Add chunk limits** to StreamingBuffer class:
```typescript
class StreamingBuffer {
  private MAX_CHUNKS_PER_PROVIDER = 500;
  private chunkCounts = new Map<string, number>();
  
  addDelta(providerId: string, delta: string, status: string, responseType: ResponseType) {
    // ... existing code
    
    // Track chunk count
    const count = (this.chunkCounts.get(key) || 0) + 1;
    this.chunkCounts.set(key, count);
    
    // Force flush if limit reached
    if (count >= this.MAX_CHUNKS_PER_PROVIDER) {
      console.warn(`[StreamingBuffer] Max chunks reached for ${key}, forcing flush`);
      this.flushImmediate();
      return;
    }
    
    // ... rest of method
  }
}
```

2. **Add memory cleanup** in `flushAll()`:
```typescript
flushAll() {
  // ... existing code
  
  // Clear arrays to free memory
  this.pendingDeltas.forEach((entry) => {
    entry.deltas.length = 0;
  });
  
  this.pendingDeltas.clear();
  this.chunkCounts.clear();
}
```

3. **Add getMemoryStats()** method for monitoring:
```typescript
getMemoryStats() {
  let totalChunks = 0;
  let totalBytes = 0;
  
  this.pendingDeltas.forEach((entry) => {
    totalChunks += entry.deltas.length;
    entry.deltas.forEach(d => {
      totalBytes += (d.text?.length || 0) * 2;
    });
  });
  
  return {
    providers: this.pendingDeltas.size,
    totalChunks,
    totalBytes,
    estimatedMB: (totalBytes / 1024 / 1024).toFixed(2),
  };
}
```

### Target File: `src/core/workflow-engine.js`

### Changes Required:

1. **Create SessionRegistry** (new file: `src/core/session-registry.js`):
   - Copy the SessionRegistry class from the artifact
   - Export as singleton: `export const sessionRegistry = new SessionRegistry();`

2. **Import and use** in workflow-engine.js:
```javascript
import { sessionRegistry } from './session-registry.js';

async execute(request, resolvedContext) {
  const sessionId = context.sessionId;
  const session = sessionRegistry.register(sessionId);
  
  try {
    // Track resources
    session.addResource(streamingBufferRef.current, 'buffer');
    
    // ... workflow execution
    
  } finally {
    // Always cleanup
    sessionRegistry.unregister(sessionId);
    clearDeltaCache(sessionId);
  }
}
```

### Validation:
- Monitor memory usage in Chrome Task Manager during long sessions
- Check console for memory warnings (max chunks reached)
- Run workflow for 10+ minutes, verify memory doesn't exceed 500MB
- Check `__HTOS_SESSION_REGISTRY.getMemoryStats()` in console

---

## 4. Persistence Layer - Single Source of Truth

### Target File: `src/sw-entry.js`

### Changes Required:

1. **Add module-level singletons** at the top:
```javascript
let persistenceLayerSingleton = null;
let sessionManagerSingleton = null;
let adapterSingleton = null;
```

2. **Update initializePersistence()** to use singleton pattern:
```javascript
async function initializePersistence() {
  // Return existing singleton if already initialized
  if (persistenceLayerSingleton) {
    console.log('[Persistence] Reusing existing persistence layer singleton');
    return persistenceLayerSingleton;
  }

  try {
    console.log('[Persistence] Creating NEW persistence layer (SSOT)');
    
    // Create adapter singleton
    adapterSingleton = new SimpleIndexedDBAdapter();
    await adapterSingleton.init({ timeoutMs: 8000, autoRepair: true });
    
    // Wrap in persistence layer
    persistenceLayerSingleton = {
      adapter: adapterSingleton,
      close: async () => { await adapterSingleton.close(); },
    };
    
    self.__HTOS_PERSISTENCE_LAYER = persistenceLayerSingleton;
    
    return persistenceLayerSingleton;
  } catch (error) {
    // Reset singletons on failure
    persistenceLayerSingleton = null;
    adapterSingleton = null;
    throw error;
  }
}
```

3. **Update initializeSessionManager()** to validate and reuse singleton:
```javascript
async function initializeSessionManager(persistenceLayer) {
  // Reuse if adapter is ready
  if (sessionManagerSingleton && sessionManagerSingleton.adapter?.isReady()) {
    console.log('[SessionManager] Reusing existing SessionManager singleton');
    return sessionManagerSingleton;
  }

  // Clear stale instance
  if (sessionManagerSingleton && !sessionManagerSingleton.adapter?.isReady()) {
    console.warn('[SessionManager] Clearing stale SessionManager instance');
    sessionManagerSingleton = null;
  }

  try {
    console.log('[SessionManager] Creating NEW SessionManager (SSOT)');
    
    sessionManagerSingleton = new SessionManager();
    sessionManagerSingleton.sessions = __HTOS_SESSIONS;
    
    // Inject SSOT adapter
    await sessionManagerSingleton.initialize({ 
      adapter: persistenceLayer?.adapter 
    });
    
    return sessionManagerSingleton;
  } catch (error) {
    sessionManagerSingleton = null;
    throw error;
  }
}
```

4. **Add validation function**:
```javascript
function validateSingletons() {
  const checks = {
    persistenceLayer: !!persistenceLayerSingleton,
    adapter: !!adapterSingleton && adapterSingleton.isReady(),
    sessionManager: !!sessionManagerSingleton,
    sessionManagerAdapter: sessionManagerSingleton?.adapter === adapterSingleton,
  };

  console.log('[Validation] Singleton checks:', checks);
  return Object.values(checks).every(Boolean);
}

// Expose for debugging
globalThis.__HTOS_VALIDATE_SINGLETONS = validateSingletons;
```

### Optional: DI Container (Advanced)

If you want to use the Dependency Injection pattern:

1. **Create new file**: `src/core/di-container.js`
   - Copy the DIContainer class from artifact
   - Export container instance

2. **Update initializeGlobalServices()** to use container:
```javascript
const persistenceLayer = await container.resolve('PersistenceLayer');
const sessionManager = await container.resolve('SessionManager');
// ... etc
```

### Validation:
- After SW starts, run in console: `__HTOS_VALIDATE_SINGLETONS()`
- Should return `true` for all checks
- Check console for "Reusing existing X singleton" on reconnect
- Verify no "createSessionManager is not a function" errors
- Monitor Chrome storage for duplicate DB connections (should be exactly 1)

---

## Testing Checklist

### After All Changes:

1. **Basic Flow**:
   - [ ] Extension loads without errors
   - [ ] Can send a message to multiple providers
   - [ ] Streaming works for all providers
   - [ ] Synthesis and mapping complete successfully

2. **Error Handling**:
   - [ ] Disconnect network during request â†’ See error message (not spinner)
   - [ ] Simulate provider timeout â†’ Partial results display
   - [ ] Refresh during streaming â†’ Resumes correctly

3. **Memory**:
   - [ ] Long session (30+ messages) â†’ Memory < 500MB
   - [ ] Check `__HTOS_SESSION_REGISTRY.getMemoryStats()` â†’ Reasonable numbers
   - [ ] No console warnings about memory limits

4. **Persistence**:
   - [ ] Run `__HTOS_VALIDATE_SINGLETONS()` â†’ All true
   - [ ] Restart SW â†’ Sessions load correctly
   - [ ] No duplicate DB connections in Chrome

5. **Performance**:
   - [ ] CPU throttle 4x â†’ Extension still responsive
   - [ ] Slow network â†’ Streaming still smooth
   - [ ] No UI freezes during heavy load

---

## Rollback Plan

If issues arise, rollback in reverse order:

1. Comment out Persistence SSOT changes (keep old implementation)
2. Comment out Memory Management limits (keep basic buffer)
3. Comment out Error Handling callbacks (keep basic try-catch)
4. Revert Bootloader changes (keep blocking init)

Then debug each component individually.

---

## Monitoring

Add these to console for debugging:

```javascript
// Check singleton status
__HTOS_VALIDATE_SINGLETONS()

// Check memory usage
__HTOS_SESSION_REGISTRY.getMemoryStats()

// Check streaming buffer
// (access via component state or add to window)

// Check error handler stats
__HTOS_ERROR_HANDLER.getErrorStats()
```

---

## Next Steps

After these 4 critical fixes are stable:

1. Add Circuit Breakers (Week 2)
2. Add Rate Limiting (Week 2)
3. Implement Observability/Logging (Week 2)
4. Add Data Migrations (Week 3)
5. Set up Testing Infrastructure (Week 3-4)

Each of these builds on the foundation we're establishing now.
I've successfully tackled the **4 highest-priority technical debt items** with production-ready implementations:

### âœ… **1. Service Worker Bootloader** (HIGHEST PRIORITY)
**Problem**: SW could terminate before listeners attach on slow machines  
**Solution**: Hybrid "Stall-and-Load" pattern
- Listeners attached **synchronously** (immediate)
- DNR rules run **eagerly** (before any network requests)
- Full services initialized **lazily** (in background)
- Listeners await services promise (stall-and-load)

**Impact**: Prevents "extension completely dead" on user machines

---

### âœ… **2. Error Boundaries & Silent Failures** (CRITICAL)
**Problem**: Provider failures freeze UI forever  
**Solution**: Comprehensive error handling
- Added `onError` callback to orchestrator
- Graceful degradation with partial results
- Standardized error types (WorkflowError class)
- Try-catch wrapping for all workflow steps
- React ErrorBoundary for UI protection

**Impact**: Users see error messages instead of frozen spinners

---

### âœ… **3. Memory Management** (CRITICAL)
**Problem**: 10,000+ intermediate strings cause 2GB memory leaks  
**Solution**: Resource tracking and limits
- Max 500 chunks per provider (forced flush)
- WorkflowSession class with automatic cleanup
- SessionRegistry for abandoned session detection
- FinalizationRegistry for automatic GC
- Memory stats API for monitoring

**Impact**: Prevents Chrome from killing extension due to memory

---

### âœ… **4. Persistence SSOT** (HIGH PRIORITY)
**Problem**: Multiple SessionManager instances cause race conditions  
**Solution**: Singleton pattern with DI container
- Module-level singletons (one adapter, one SessionManager)
- Dependency Injection container (optional advanced pattern)
- Validation functions to verify SSOT
- Clear initialization order (persistence â†’ session â†’ services)

**Impact**: Prevents data corruption and DB deadlocks

---

## Integration Path

The **Integration Guide artifact** provides step-by-step instructions for your IDE agent:

1. **SW Bootloader**: Modify `sw-entry.js` listener attachment order
2. **Error Handling**: Add `onError` callbacks in `workflow-engine.js`
3. **Memory Management**: Update `streamingBuffer.ts` with limits + create `session-registry.js`
4. **Persistence SSOT**: Add singleton guards in `sw-entry.js` initialization

Each section includes:
- Target files
- Exact code changes
- Validation steps
- Rollback instructions

## Validation

After implementation, run these checks:

```javascript
// 1. Validate singletons
__HTOS_VALIDATE_SINGLETONS() // Should return true

// 2. Check memory usage
__HTOS_SESSION_REGISTRY.getMemoryStats() 

// 3. Check error stats
__HTOS_ERROR_HANDLER.getErrorStats()
```

## Next Steps

Once these 4 fixes are stable, prioritize:
- **Week 2**: Circuit Breakers, Rate Limiting, Observability
- **Week 3**: Data Migrations, Testing Infrastructure
- **Week 4**: CI/CD, Performance Budgets

These changes establish the **safety foundation** needed to turn your "F1 prototype into a production vehicle" ðŸŽï¸â†’ðŸš—